
PARSING!  YAY!
======================================================================
Chapter 4 dragon
Chapter 3 engineering a compiler


Parsing will be similar to lexing in the sense that we will:
  use some formal thing to define legal sentences
  then derive a parser automatically?

Unfortunately: regexes won't work for parsing

  a(b(c(d(e))));

this won't work for regexes

We'll use "context-free" grammars which are the next most powerful thing.

A grammar is similar to a notation called BNF

Idea:
  * define symbols for pieces of the language
    using rules called "productions"

  * each symbol can be either a token (like from the lexer),
    including empty string epsilon -> called "terminals"

    or a variable for a collection of tokens, called "non-terminals"

  * One of the non-terminals is designated as the "start" symbol

    Typically it's the first production in the list



Example for our wimpy compiler

  E -> E + E   |   E * E   |   number

| : or

  -> : is

  An expression (E) is, either,
    an expression + expression,
  or
    an expression * expression
  or
    number


From now on though:

  (1) E -> E + E
  (2) E -> E * E
  (3) E -> number

3 rules or 3 productions here.

E is a non-terminal symbol.  And it is the start symbol.

+, *, number: are terminals / tokens
                (lexer gives us these)


How this works:
A sequence of tokens will match a non-terminal symbol
if there exists a sequence of production rules
that will produce that sequence of tokens.
If so we get a "derivation"

E.g:
Is there a derivation for

number + number * number

E -> E + E -> E + (E * E) -> number + (E * E) -> number + (number * E)
  -> number + (number * number)

E -> E * E -> (E + E) * E ->  etc.

There is a derivation for number + number * number


We will write

  symbol ->*  sequence

if there is a derivation of symbol that produces the sequence

E ->* E + E * E


A "sentence" is a sequence with only terminals, that can be derived
  from the start symbol.

number + number * number is a sentence.


For a grammar G with start symbol S,
  the lanugage generated by G, denoted L(G),
  is the set of all sentences derivable from S

    w in L(g)  iff  S ->* w    and w contains only terminals



Parse trees:

  These are a graphical representation of a derivation

  * Interior nodes: application of a production

      label these nodes with LHS of the production

      children will correspond to RHS of the production


  * leaves will be terminals if it's a sentence,
    otherwise could be mixed


Example parse tree(s)?
for our sentence number + number * number:

                      E
                    / | \
                   E  +  E
                  /     /|\
                 /     / | \
                /     E  *  E
             number   |     |
                    number  number


Is there another parse tree?  YES

                      E
                    / | \
                   E  *  E
                  /|\     \
                 / | \     \
                E  +  E     \
                |     |      \
            number  number   number


A grammar that produces more than one parse tree
for some sentence is said to be ambiguous.  (BAD)

This grammar is not the "right" grammar for our wimpy compiler.

    (It's not capturing * is higher prec. than +)


One way: let's rewrite the grammar:

  S -> S + S
  S -> P
  P -> P * P
  P -> number

Idea: expression is a sum of things, each thing can be a product

This forces * to have higher precedence than +.

"homework":
  what's the parse tree for number + number * number

  is this grammar ambiguous or not?

                      S
                    / | \
                   S  +  S
                  /      |
                 P       P
                /       /|\
               /       / | \
               |      P  *  P
             number   |     |
                    number  number


Good: there's only one parse tree for this sentence.

        number + number + number


                      S
                    / | \
                   S  +  S
                  /     /|\
                 /     / | \
                /     S  +  S
                |     |     |
                P     P     P
                |     |     |
             number   |     |
                    number  number


                      S
                    / | \
                   S  +  S
                  /|\     \
                 / | \     \
                S  +  S     \
                |     |      \
                P     P       P
                |     |       |
            number  number   number


Two parse trees -> still ambiguous

The problem is:
  first tree expresses   number + (number + number)
  second tree expresses  (number + number) + number

Who cares?

  i = 2;
  j = (i=3) + 4 + i;

      ( ( i=3) + 4 ) + i      j gets 10

      (i=3) +  (4+i)          j gets 9


We'll do (number + number) + number

Here's the correct grammar:

  S -> S + P
  S -> P
  P -> P * number
  P -> number

This one is not ambiguous.

Another approach: disambiguating rules

These rules specify "which parse tree" is correct

  (1) precedence of operators
      e.g., * is higher prec than +
      "tie breakers for different operators"

      E -> E * E
      E -> E + E
      E -> number

      Could generalize this to
        "first production has precedence over second"

  (2) associativity of operators
      "tie breaker for the same operator"

      if we have a sequence of the same operator, do we go
      left to right or right to left or not allowed


      options:

        left associative: go from left to right
                          a + b + c + d   =   (((a+b)+c)+d)

        right associative: go from right to left
                            a = b = c = 5;
                            a = (b = (c = 5));

        non associative: not allowed to chain
                            a $ b $ c


Dangling else:

  if (x>0)
    if (y>0)
       printf("hi\n");
  else  // this goes with if y>0
    printf("ho\n");
  else  // this goes with if x>0
    printf("hum\n");

Rule:
    else matches the nearest un-elsed if


  (1) stmt -> if ( expr ) stmt ;
  (2) stmt -> if ( expr ) stmt ; else stmt ;

The way most languages work:  give precedence to (2).



Goal:
  From a grammar, how to build a parser?

          ^
        unambiguous, or ambiguous with disambiguating rules

Plan for lectures:

  * some terminology / theory
  * top-down parsing  (great for by hand)
  * bottom-up parsing (used by tools)
  * yacc/bison

Some terminology:

  A derivation is a sequence of substitutions
  starting with the start symbol,
  ending with the desired sentence.

Another way to think of this:

  For a given parse tree, a derivation is an order to build the tree.

Definitions:
  A leftmost derivation: will always replace the left-most nonterminal symbol.
  A rightmost derivation: will always replace the right-most nonterminal symbol.

                      S
                    / | \
                   S  +  S
                  /      |
                 P       P
                /       /|\
               /       / | \
               |      P  *  P
             number   |     |
                    number  number


Leftmost derivation:
    S
    S+P
    P+P
    number+P
    number+P*P
    number+number*P
    number+number*number

Rightmost derivation
    S
    S+P
    S+P*P
    S+P*number
    S+number*number
    P+number*number
    number+number*number

Different types of parsers will produce types of derivations
  (i.e., leftmost or rightmost)

Recursion: left vs right

List of variables in a declaration:

  int a;
  int b, c, d, e, f;

Grammar:
  var_decl -> type varlist ;

  varlist -> varlist , ident
  varlist -> ident

  ^ left recursion

  varlist -> ident , varlist
  varlist -> ident

  ^ right recursion


Left recursion: does left associativity

  int a, b, c;

  varlist
  varlist , ident
  (varlist , ident) , ident
  (ident , ident) , ident

Right recursion: does right associativity


Leftmost derivations: have trouble with left recursion
Rightmost derivations: less efficient with right recursion


Classes of grammars
------------------------------------------------------------
Parsers have names like LL(1) and LR(2)

What do these mean?

  First L: input stream is scanned from left to right.

  Second L: leftmost derivation
  Second R: rightmost derivation

  the number: how many lookahead tokens do I need?

A grammar belongs to a class if we can write that kind of parser for it.

  LL(1) is a subset of LL(2) is a subset of LL(3)

Good: almost all programming languages belong to LL(1) and LR(1)


Top-down vs bottom up
------------------------------------------------------------

Top-down parsing:
    we build the parse tree top-down
    i.e., start at the root, expand down, depth-first, to the left

    -> finds a leftmost derivation
    -> will be LL(1), LL(2) etc.
    -> Usually the method of choice when parsing "by hand"
    -> gcc uses this!


Bottom up parsing:
    we build the parse tree bottom up
    start from the leaves, build little subtrees bottom up
    and connect them as we go until we get to the root

    -> will find a rightmost derivation
    -> will be LR(0), LR(1), etc
    -> a pain by hand
    -> automatic tools use this


Note: neither parser may actually construct the parse tree.


