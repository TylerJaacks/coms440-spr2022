
PARSING!  YAY!
======================================================================
Chapter 4 dragon
Chapter 3 engineering a compiler


Parsing will be similar to lexing in the sense that we will:
  use some formal thing to define legal sentences
  then derive a parser automatically?

Unfortunately: regexes won't work for parsing

  a(b(c(d(e))));

this won't work for regexes

We'll use "context-free" grammars which are the next most powerful thing.

A grammar is similar to a notation called BNF

Idea:
  * define symbols for pieces of the language
    using rules called "productions"

  * each symbol can be either a token (like from the lexer),
    including empty string epsilon -> called "terminals"

    or a variable for a collection of tokens, called "non-terminals"

  * One of the non-terminals is designated as the "start" symbol

    Typically it's the first production in the list



Example for our wimpy compiler

  E -> E + E   |   E * E   |   number

| : or

  -> : is

  An expression (E) is, either,
    an expression + expression,
  or
    an expression * expression
  or
    number


From now on though:

  (1) E -> E + E
  (2) E -> E * E
  (3) E -> number

3 rules or 3 productions here.

E is a non-terminal symbol.  And it is the start symbol.

+, *, number: are terminals / tokens
                (lexer gives us these)


How this works:
A sequence of tokens will match a non-terminal symbol
if there exists a sequence of production rules
that will produce that sequence of tokens.
If so we get a "derivation"

E.g:
Is there a derivation for

number + number * number

E -> E + E -> E + (E * E) -> number + (E * E) -> number + (number * E)
  -> number + (number * number)

E -> E * E -> (E + E) * E ->  etc.

There is a derivation for number + number * number


We will write

  symbol ->*  sequence

if there is a derivation of symbol that produces the sequence

E ->* E + E * E


A "sentence" is a sequence with only terminals, that can be derived
  from the start symbol.

number + number * number is a sentence.


For a grammar G with start symbol S,
  the lanugage generated by G, denoted L(G),
  is the set of all sentences derivable from S

    w in L(g)  iff  S ->* w    and w contains only terminals



Parse trees:

  These are a graphical representation of a derivation

  * Interior nodes: application of a production

      label these nodes with LHS of the production

      children will correspond to RHS of the production


  * leaves will be terminals if it's a sentence,
    otherwise could be mixed


Example parse tree(s)?
for our sentence number + number * number:

                      E
                    / | \
                   E  +  E
                  /     /|\
                 /     / | \
                /     E  *  E
             number   |     |
                    number  number


Is there another parse tree?  YES

                      E
                    / | \
                   E  *  E
                  /|\     \
                 / | \     \
                E  +  E     \
                |     |      \
            number  number   number


A grammar that produces more than one parse tree
for some sentence is said to be ambiguous.  (BAD)

This grammar is not the "right" grammar for our wimpy compiler.

    (It's not capturing * is higher prec. than +)


One way: let's rewrite the grammar:

  S -> S + S
  S -> P
  P -> P * P
  P -> number

Idea: expression is a sum of things, each thing can be a product

This forces * to have higher precedence than +.

"homework":
  what's the parse tree for number + number * number

  is this grammar ambiguous or not?


